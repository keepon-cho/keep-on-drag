<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>keep on drag</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      height: 100vh;
      background: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      color: #111;
      user-select: none;
      touch-action: none; /* 터치 드래그 시 스크롤 방지 */
    }

    .wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
    }

    .label {
      font-size: 14px;
      opacity: 0.85;
      text-align: center;
      line-height: 1.5;
    }

    #shape {
      width: 220px;
      height: 220px;
      position: relative;
    }

    /* SVG는 한 개의 path만 사용해서 육각형 ↔ 원 변형 */
    #hexCircle {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* 위로 드래그했을 때 표시할 큐브 레이어 (위에 겹쳐져서 보임) */
    .cube-layer {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      opacity: 0;          /* JS에서 0~1로 조절 */
      transition: opacity 0.08s linear;
    }

    .cube {
      position: relative;
      width: 89%;
      height: 89%;
      clip-path: polygon(
        50% 0%,
        93.3% 25%,
        93.3% 75%,
        50% 100%,
        6.7% 75%,
        6.7% 25%
      );
    }

    .cube-face {
      position: absolute;
      inset: 0;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.7);
    }

    .cube-face.top {
      clip-path: polygon(
        50% 0%,
        93.3% 25%,
        50% 50%,
        6.7% 25%
      );
      background: radial-gradient(circle at 30% 20%, #666 0%, #111 60%, #000 100%);
    }

    .cube-face.left {
      clip-path: polygon(
        6.7% 25%,
        50% 50%,
        50% 100%,
        6.7% 75%
      );
      background: linear-gradient(135deg, #050505 0%, #151515 60%, #222 100%);
    }

    .cube-face.right {
      clip-path: polygon(
        93.3% 25%,
        50% 50%,
        50% 100%,
        93.3% 75%
      );
      background: linear-gradient(45deg, #141414 0%, #1f1f1f 50%, #000 100%);
    }

    .hint {
      font-size: 12px;
      opacity: 0.6;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="label">
      위/아래로 드래그해 보세요.<br />
    </div>

    <div id="shape">
      <!-- 한 개의 path가 육각형 ↔ 내접원으로 morph -->
      <svg id="hexCircle" viewBox="-1.3 -1.3 2.6 2.6">
        <path id="morphPath" fill="#000" />
      </svg>

      <!-- 위로 드래그할 때 보이는 큐브 레이어 -->
      <div id="cubeLayer" class="cube-layer">
        <div class="cube">
          <div class="cube-face top"></div>
          <div class="cube-face left"></div>
          <div class="cube-face right"></div>
        </div>
      </div>
    </div>


  </div>

  <script>
    const shapeEl = document.getElementById("shape");
    const pathEl = document.getElementById("morphPath");
    const cubeLayer = document.getElementById("cubeLayer");

    let isDragging = false;
    let startY = 0;
    let startAmount = 0;
    let currentAmount = 0; // -1 ~ 1  (아래: -1 쪽 / 위: +1 쪽)

    const RANGE = 120;

    // === 정육각형 ↔ 내접원 morph 수학 부분 ===
    // 인접한 6개의 변을 가진 정육각형을 "내접원 반지름 r=1"로 설정
    // 각 변의 법선 벡터
    const normals = [
      { x:  1,           y:  0          }, // 오른쪽
      { x:  0.5,         y:  Math.sqrt(3)/2 }, // 오른쪽 위
      { x: -0.5,         y:  Math.sqrt(3)/2 }, // 왼쪽 위
      { x: -1,           y:  0          }, // 왼쪽
      { x: -0.5,         y: -Math.sqrt(3)/2 }, // 왼쪽 아래
      { x:  0.5,         y: -Math.sqrt(3)/2 }  // 오른쪽 아래
    ];

    const inradius = 1;                             // 내접원 반지름
    const Rmax = 2 / Math.sqrt(3);                 // 꼭짓점까지의 최대 거리 (외접 반지름)

    // 주어진 각도 theta 방향으로 정육각형의 경계까지의 거리 r_hex(theta) 계산
    function rHex(theta) {
      const ux = Math.cos(theta);
      const uy = Math.sin(theta);
      let r = Infinity;

      for (const n of normals) {
        const dot = n.x * ux + n.y * uy;
        if (dot > 0) { // 이 면을 향해 있는 방향만 고려
          const cand = inradius / dot;
          if (cand < r) r = cand;
        }
      }
      return r;
    }

    // t ∈ [0, 1]
    // t = 0   → 정육각형
    // t = 1   → 반지름 inradius인 완전한 원
    function buildPath(t) {
      const steps = 120; // 점 개수 (많을수록 더 smooth)
      let d = "";

      for (let i = 0; i <= steps; i++) {
        const theta = (2 * Math.PI * i / steps) - Math.PI / 2; // 위쪽부터 시작

        const r_hex = rHex(theta);
        const r = (1 - t) * r_hex + t * inradius; // 선형 보간

        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);

        d += (i === 0 ? "M" : "L") + x.toFixed(4) + " " + y.toFixed(4) + " ";
      }

      d += "Z";
      pathEl.setAttribute("d", d);
    }

    // === 인터랙션 ===
    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function updateVisual() {
      const down = Math.max(0, -currentAmount); // 0~1 (아래로 드래그 정도)
      const up   = Math.max(0,  currentAmount); // 0~1 (위로 드래그 정도)

      // 아래로 드래그: 정육각형 → 내접원으로 morph
      buildPath(down);

      // 위로 드래그: 큐브 레이어 불투명도
      cubeLayer.style.opacity = up.toFixed(3);
    }

    function pointerY(e) {
      return e.clientY;
    }

    shapeEl.addEventListener("pointerdown", (e) => {
      isDragging = true;
      startY = pointerY(e);
      startAmount = currentAmount;

      if (shapeEl.setPointerCapture) {
        shapeEl.setPointerCapture(e.pointerId);
      }
    });

    window.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const y = pointerY(e);
      const deltaY = y - startY;

      const deltaAmount = -deltaY / RANGE;
      currentAmount = clamp(startAmount + deltaAmount, -1, 1);
      updateVisual();
    });

    window.addEventListener("pointerup", (e) => {
      if (!isDragging) return;
      isDragging = false;

      if (shapeEl.releasePointerCapture) {
        try { shapeEl.releasePointerCapture(e.pointerId); } catch (_) {}
      }

      // 손을 떼면 다시 정육각형으로 복귀
      currentAmount = 0;
      updateVisual();
    });

    window.addEventListener("pointercancel", () => {
      isDragging = false;
      currentAmount = 0;
      updateVisual();
    });

    // 처음 상태: t=0 → 정육각형
    buildPath(0);
  </script>
</body>
</html>
